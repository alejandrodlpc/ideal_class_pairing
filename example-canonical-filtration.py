#!/usr/bin/env python
# coding: utf-8

# # Example of the Canonical Filtration of an Elliptic Curve

# Here we present a thoroughly worked out example of the canonical filtration of an elliptic curve over a number field.

# ## 1. Number Field

# Here we fix the following:
# 
# 1. a number field `K` generated by `t` with defining polynomial `def_poly`,
# 2. the polynomial ring `R` in two variables `x1` and `x2` over the number field `K`,
# 3. a prime ideal `p` of `K` by factoring a random principal ideal and choosing its first prime factor,
# 4. a uniformizer `pi` of the valuation ring of `K` with respect to `p`, 
# 5. the valuation `v` associated to `p`.
# 6. the residue field `k` of `K` modulo `p`.
# 7. the reduction map `red` from $\mathcal{O}_K\rightarrow\mathcal{O}_K/\mathfrak{p}\mathcal{O}_K\cong \mathcal{O}_{\mathfrak{p}}/\mathfrak{p}\mathcal{O}_{\mathfrak{p}}$ 
# 8. the polynomial ring `Rp` in two variables `y1` and `y2` over the residue field `k`

# In[1]:


#1. Number Field
def_poly = x^2 - 3
K.<t> = NumberField(def_poly)
print('K =',K)

#2. Polynomial Ring
R.<x1,x2> = K[]
print('R =',R)

#3. Prime ideal
random_principal_ideal = K.ideal(11)
p = random_principal_ideal.factor()[0][0]
print('p =',p)

#4. Uniformizer
pi = K.uniformizer(p)
print('pi =',pi,'is a uniformzer')

#5. Valuation
v = K.valuation(p)
print('the associated valuation is v =',v)

#6. Residue field
k = K.residue_field(p)
print('k =',k,'of order =',k.order())

#7. Reduction map
red = k.reduction_map()
example_reduction = 7 + t
print('red = reduction map modulo p, for example, red(',example_reduction,') =',red(example_reduction))

#8. Polynomial ring over the residue field
Rp.<y1,y2> = k[]
print('Rp =',Rp)


# ## 2. Elliptic curve constructions

# In this section we create the following:

# ---
# 
# A function `w_poly` that returns a Weierstass polynomial in `x1` and `x2` the input is a list `[a1,a2,a3,a4,a6]` and it returns the polynomial
# > $y^2 + a_1 xy + a_3 y - (x^3 + a_2 x^2 + a_4 x + a_6)$

# In[2]:


# Weierstrass polynomial
def w_poly(coef_list):
     return x2^2 + coef_list[0]*x1*x2 + coef_list[2]*x2 - (x1^3 + coef_list[1]*x1^2 + coef_list[3]*x1 + coef_list[4])


# ---
# 
# #### Weierstrass Coefficients for the $\mathfrak{p}$-level $n$ model $E^n$
# 
# A function `pleveln_weierstrass_coefficients` that takes as input
# 
# - `field` = a number field $K$,
# - `prime_ideal` = a prime ideal $\mathfrak{p}$ of $K$,
# - `lvl` = a nonnegative integer $n\geq0$
# - `a_list` = A list [a1,a2,a3,a4,a6] of Weierstrass coefficients defining an elliptic curve $E:y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6$ over $K$,
# 
# and returns
# 
# - a list `[a1',a2',a3',a4',a6']` of Weierstrass coefficients that define the $\mathfrak{p}$-level $n$ model $E^n$ of $E$.

# In[3]:


def pleveln_weierstrass_coefficients(field,prime_ideal,lvl,a_list):
    w_model_E = EllipticCurve(a_list)
    min_model_E = w_model_E.global_minimal_model(semi_global=True)
    min_a_list = list(min_model_E.a_invariants())
    unif = field.uniformizer(prime_ideal)
    return [a_list[0]*unif^(lvl),a_list[1]*unif^(2*lvl),a_list[2]*unif^(3*lvl),a_list[3]*unif^(4*lvl),a_list[4]*unif^(6*lvl)]


# Example:

# In[4]:


# Weierstrass coefficients
a_list = [0,0,0,-2,5]
E = EllipticCurve(K,a_list)
print('E =',E)
print('---')

lvl = 3
lvl_a_list = pleveln_weierstrass_coefficients(K,p,lvl,a_list)
print('E ^',lvl,' =',EllipticCurve(K,lvl_a_list))


# Below, we list the Weierstrass coefficients of $E^0,E^1,E^2,E^3,\ldots,E^5$

# In[5]:


# Weierstrass coefficients
a_list = [0,0,0,-2,5]

E = EllipticCurve(K,a_list)
print('E =',E)
print('---')

for lvl in (0..4):
    lvl_a_list = pleveln_weierstrass_coefficients(K,p,lvl,a_list)
    print('E ^',lvl,' =',lvl_a_list)


# ---
# 
# #### Points on $E^n$
# 
# A function `pleveln_point_coords` that takes as input
# 
# - `field` = a number field $K$,
# - `prime_ideal` = a prime ideal $\mathfrak{p}$ of $K$,
# - `lvl` = a nonnegative integer $n\geq0$
# - `a_list` = A list [a1,a2,a3,a4,a6] of Weierstrass coefficients defining an elliptic curve $E:y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6$ over $K$,
# - `point` = a point $P$ on $E(K)$
# 
# and returns
# 
# - the coordinates $\lbrack x:y:z \rbrack$ of the corresponding point $P^n$ on the $\mathfrak{p}$-level $n$ model $E^n$ of $E$.

# In[6]:


def pleveln_point_coords(field,prime_ideal,lvl,a_list,point):
    unif = field.uniformizer(prime_ideal)
    En = EllipticCurve(pleveln_weierstrass_coefficients(field,prime_ideal,lvl,a_list))
    point_coord = list(point.xy())
    new_point = [unif^(2*lvl)*point_coord[0],unif^(3*lvl)*point_coord[1]]
    return En(new_point)


# For example, we list the coordinates of $P\in E(K)$ in $E^0,E^1,E^2,E^3,E^4,E^5$

# In[7]:


# Weierstrass coefficients
a_list = [0,0,0,-2,5]

E = EllipticCurve(K,a_list)
print('E =',E)

point = E.gens()[2]
print('P =',point)

print('---')

for lvl in (0..4):
    lvl_coords = pleveln_point_coords(K,p,lvl,a_list,point)
    print('level =',lvl,'|',lvl_coords)


# ---
# 
# #### Singular vs. Nonsingular Reduction
# 
# A function `reduction_mod_p` that takes as input
# 
# - `field` = a numberfield $K$,
# - `prime_ideal` = a prime ideal $\mathfrak{p}$ of $K$,
# - `a_list` = A list [a1,a2,a3,a4,a6] of Weierstrass coefficients defining a possibly singular elliptic curve $E:y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6$ over $K$,
# - `point` = a point $P$ on $E(K)$
# 
# and returns
# 
# - [$\widetilde{P},C$] = a pair with $\widetilde{P}$ is the reduction modulo $\mathfrak{p}$ of the point $P\in E(K)$ on the curve $C=\widetilde{E}(k)$, where $k$ is the residue field $k=\mathcal{O}_K/\mathfrak{p}$.

# In[8]:


def reduction_mod_p(field,prime_ideal,a_list,point):
    
    # Define residue field and reduction map
    res_field = field.residue_field(prime_ideal)
    red_map = res_field.reduction_map()
    unif = field.uniformizer(prime_ideal)
    
    # x and y coordinates of point and their valuations
    x_point = point.xy()[0]
    y_point = point.xy()[1]
    v_x_point = x_point.valuation(prime_ideal)
    v_y_point = y_point.valuation(prime_ideal)
    
    # Clear denominators by multiplying the projective coordinates by the smallest necessary power of unif
    min_val = min(v_x_point,v_y_point)
    
    if min_val<0:
        unif_exp = min_val
    else:
        unif_exp = 0

    integral_x_point = x_point*unif^(-unif_exp)
    integral_y_point = y_point*unif^(-unif_exp)
    integral_z_point = unif^(-unif_exp)
    
    # Reduce the elliptic curve
    
    reduced_a_list = [red_map(i) for i in a_list]
     
    red_Proj.<z1,z2,z3> = ProjectiveSpace(res_field,2)
    homogeneous_poly = z2^2 * z3 + reduced_a_list[0]*z1*z2*z3 + reduced_a_list[2]*z2*z3^2 - (z1^3 + reduced_a_list[1]*z1^2*z3 + reduced_a_list[3]*z1*z3^2 + reduced_a_list[4]*z3^3)
    E_red = Curve(homogeneous_poly)
    
    # Reduce the point
    red_x_point = red_map(integral_x_point)
    red_y_point = red_map(integral_y_point)
    red_z_point = red_map(integral_z_point)
    
    red_point = E_red([red_x_point,red_y_point,red_z_point])
    
    return [red_point,E_red]


# Below is an example that presents all the steps in the code for `reduction_mod_p`

# In[9]:


print('---INPUT---')

# Number Field
def_poly = x^2 - 5
K.<t> = NumberField(def_poly)
print('field =',K)

# Prime ideal
random_principal_ideal = K.ideal(13)
p = random_principal_ideal.factor()[0][0]
print('prime_ideal =',p)

# Elliptic Curve
a_list = [0,1,0,2,5]
E = EllipticCurve(K,a_list)
print('a_list =',a_list)

# Point on E
P = E.gens()[0]
print('point =',P)

print('---BODY---')

# Define residue field and reduction map
k = K.residue_field(p)
print('res_field =',k)
red = k.reduction_map()
print('red_map',red)
pi = K.uniformizer(p)
print('unif =',pi)
    
# x and y coordinates of point and their valuations
xP = P.xy()[0]
print('x_point =',xP)
yP = P.xy()[1]
print('y_point =',yP)

vx = xP.valuation(p)
print('v_x_point =',vx)
vy = yP.valuation(p)
print('v_y_point =',vy)
    
# Clear denominators by multiplying the projective coordinates by the smallest necessary power of unif
min_v = min(vx,vy)
print('min_val =',min_v)
    
if min_v<0:
    ordp = min_v
else:
    ordp = 0
print('unif_exp =',ordp)

int_xP = xP*pi^(-ordp)
print('integral_x_point =',int_xP)
int_yP = yP*pi^(-ordp)
print('integral_y_point =',int_yP)
int_zP = pi^(-ordp)
print('integral_z_point =',int_zP)
    
# Reduce the elliptic curve
    
red_a_list = [red(i) for i in a_list]
print('reduced_a_list =',red_a_list)
     
k_Proj.<z1,z2,z3> = ProjectiveSpace(k,2)
print('red_Proj =',k_Proj)
hom_poly = z2^2 * z3 + red_a_list[0]*z1*z2*z3 + red_a_list[2]*z2*z3^2 - (z1^3 + red_a_list[1]*z1^2*z3 + red_a_list[3]*z1*z3^2 + red_a_list[4]*z3^3)
print('homogeneous_poly =',hom_poly)
E_bar = Curve(hom_poly)
print('E_red =',E_bar)
    
# Reduce the point
red_xP = red(int_xP)
print('red_x_point =',red_xP)
red_yP = red(int_yP)
print('red_y_point =',red_yP)
red_zP = red(int_zP)
print('red_z_point =',red_zP)

red_P = E_bar([red_xP,red_yP,red_zP])
print('red_point =',red_P)

print('---OUTPUT---')

print([red_P,E_bar])


# The function `reduction_mod_p` together with `.is_singular()` allows us to check whether a point has good or bad reduction.

# In[10]:


# Number Field
def_poly = x^3 - 3
K.<t> = NumberField(def_poly)
print('K =',K)

# Prime ideal
random_principal_ideal = K.ideal(13)
p = random_principal_ideal.factor()[0][0]
print('p =',p)

# Elliptic Curve
a_list = [0,0,0,-2,5]
E = EllipticCurve(K,a_list)
print('E =',a_list)

# Point on E
P = E.gens()[0]
print('P =',P)

print('-----')

print('the reduction of P modulo p =',reduction_mod_p(K,p,a_list,P)[0],'has singular reduction:',reduction_mod_p(K,p,a_list,P)[0].is_singular())


# ## 3. Canonical Filtration of an Elliptic Curve
# 
# The canonical filtration of an elliptic curve $E/K$ is the descending sequence
# 
# > $E(K) \supseteq E_0^0(K) \supseteq E_0^1(K) \supseteq E_0^2(K) \supseteq \cdots$
# 
# where $E_0^n(K)$ is defined as the set of points of $E(K)$ that have good reduction modulo $\mathfrak{p}$ relative to a (and thus any) $\mathfrak{p}$-level $n$ Weierstrass model $\mathcal{E}$. The **$\mathfrak{p}$-level of $P\in E_0^0(K)$** is defined as the largest $n$ such that $P\in E^n_0(K)$. Below we define a function that computes this.

# ---
# 
# The function `p_level` takes as input
# 
# - `field` = a number field $K$,
# - `prime_ideal` = a prime ideal $\mathfrak{p}$ of $K$,
# - `a_list` = A list [a1,a2,a3,a4,a6] of Weierstrass coefficients defining an elliptic curve $E:y^2 + a_1 xy + a_3 y = x^3 + a_2 x^2 + a_4 x + a_6$ over $K$,
# - `point` = a point $P$ on $E(K)$
# 
# and returns
# 
# - `n` = the $\mathfrak{p}$-level of $P$.

# In[11]:


def p_level(field,prime_ideal,a_list,point):
    
    E_curve = EllipticCurve(field,a_list)
    
    if E_curve.is_local_integral_model(p):
        
        lvl = 0
        a_list_lvl = a_list
        point_lvl = point
        
        while not reduction_mod_p(field,prime_ideal,a_list_lvl,point_lvl)[0].is_singular():
            lvl += 1
            a_list_lvl = pleveln_weierstrass_coefficients(field,prime_ideal,lvl,a_list)
            point_lvl = pleveln_point_coords(field,prime_ideal,lvl,a_list,point)
        return lvl-1
    else:
        print('Weierstrass equation is not p-integral')


# In[13]:


print('---INPUT---')

# Number Field
def_poly = x^2 - 3
K.<t> = NumberField(def_poly)
print('field =',K)

# Prime ideal
random_principal_ideal = K.ideal(3)
p = random_principal_ideal.factor()[0][0]
print('prime_ideal =',p)

# Elliptic Curve
a_list = [0,0,0,-2,5]
E = EllipticCurve(K,a_list)
print('a_list =',a_list)

# Point on E
P = 3*E.gens()[2]
show('point =',P)

print('---OUTPUT---\n')

plvl = p_level(K,p,a_list,P)+1

print('p-level of P =',p_level(K,p,a_list,P),'\n')

print('---VERIFICATION---\n')
print('-------------------------------')

for n in (0..plvl):
    En_a_list = pleveln_weierstrass_coefficients(K,p,n,a_list)
    Pn = pleveln_point_coords(K,p,n,a_list,P)
    P_red = reduction_mod_p(K,p,En_a_list,Pn)[0]
    if P_red.is_singular():
        reduction_type = 'singular'
    else:
        reduction_type = 'non-singular'
    print('level =',n)
    show('coordinates of P in E^',n,' = ',Pn)
    show('valuation of x coordinate =',Pn.xy()[0].valuation(p))
    show('its reduction modulo p is = ',P_red)
    show('The reduction is:\n',reduction_type)
    print('-------------------------------')


# ---
# 
# ## Scratch

# In[ ]:


# Number Field
def_poly = x^2 - 3
K.<t> = NumberField(def_poly)
print('- K =',K)

# Polynomial Ring
R.<x1,x2> = K[]
#print('R =',R)

# Prime ideal
random_principal_ideal = K.ideal(7)
p = random_principal_ideal.factor()[0][0]
print('- p =',p)

# Uniformizer
pi = K.uniformizer(p)
print('- pi =',pi,'is a uniformzer')

# Valuation
v = K.valuation(p)
print('- the associated valuation is v =',v)

# Residue field
k = K.residue_field(p)
#print('- k =',k,'of order =',k.order())

# Reduction map
red = k.reduction_map()

# Weierstrass coefficients
a1 = 0
a3 = 1
a2 = 0
a4 = -2
a6 = 5
a_list = [a1,a2,a3,a4,a6]

# Elliptic Curve defined by the above Weierstrass coefficients
E = EllipticCurve(K,a_list)
print('- E =',E)

E_min = E.global_minimal_model(semi_global=True)
print('- E_min =',E_min)

# Point on E
P = 2*E_min.gens()[2]
print('- point P =',P,'on minimal model of E.')

print('-----')

# lvl
#lvl = 0
#while [red(i) for i in pleveln_weierstrass_coefficients(K,p,lvl,a_list)][4] != 0:
#    red_w_coord = [red(i) for i in pleveln_weierstrass_coefficients(K,p,lvl,a_list)]
#    print(lvl,red_w_coord)
    
#    lvl += 1

#for i in (0..5):
#    print(pleveln_weierstrass_coefficients(K,p,i,a_list),[red(x) for x in pleveln_weierstrass_coefficients(K,p,i,a_list)])


# In[ ]:


1847042.factor()


# In[ ]:


K.ideal(-1847042).factor()


# In[ ]:


red(-1847042)


# In[ ]:


red


# In[ ]:


K.<s> = NumberField(x^2-7)
I = K.ideal(5)
I.factor()


# In[ ]:


a_list = [0,0,0,1,0]
E = EllipticCurve(QQ,a_list)
#E.discriminant()%5
E.discriminant()


# In[ ]:




